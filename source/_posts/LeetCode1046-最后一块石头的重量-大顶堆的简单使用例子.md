---
title: LeetCode1046. 最后一块石头的重量(大顶堆的简单使用例子)
date: 2020-09-15 13:04:17
tags:
- 简单模拟
- 简单难度
- 堆
---

 有一堆石头，每块石头的重量都是正整数。每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。

<!-- more -->

假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

    如果 x == y，那么两块石头都会被完全粉碎；
    如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

**示例：**

输入：[2,7,4,1,8,1]
输出：1

**解释：**
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。

**提示：**

    1 <= stones.length <= 30
    1 <= stones[i] <= 1000



**思路：**

这道题可以作为堆的使用的简单例子，维护一个大顶堆，每次从堆里取两个数出来判断，然后再判断即可。

这里插入c++中STL中堆的使用：

STL中堆是利用 **priority_queue**实现的。

优先队列是容器适配器的一种类型，特别设计为它的第一个元素总是它包含的元素中最大的元素，根据一些严格的弱顺序标准。

这个上下文类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素(优先级队列顶部的元素)。

优先级队列被实现为容器适配器，这些适配器类使用特定容器类的封装对象作为其底层容器，提供一组特定的成员函数来访问其元素。元素从特定容器的“后面”弹出，该容器称为优先级队列的顶部。

底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应通过随机访问迭代器访问，并支持以下操作:

1. **empty()** 如果优先队列为空，则返回真
2. **pop()** 删除第一个元素
3. **push()** 加入一个元素
4. **size()** 返回优先队列中拥有的元素的个数
5. **top()** 返回优先队列中有最高优先级的元素

标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指定容器类，则使用标准容器向量。

任何时候都需要支持随机访问迭代器，以便在内部保持堆结构。这是由容器适配器通过在需要时自动调用算法函数make_heap、push_heap和pop_heap来自动完成的。

**大顶堆：**

```cpp
	priority_queue<int> q;
    for( int i= 0; i< 10; ++i ) q.push(i);
    while( !q.empty() ){
        cout<<q.top()<<endl;
        q.pop();
    }
```



**小顶堆:**

```cpp
    priority_queue<int, vector<int>, greater<int> > q;
    for( int i= 0; i< 10; ++i ) q.push(10-i);
    while( !q.empty() ){
        cout << q.top() << endl;
        q.pop();
    }
```





**本题代码：**

```cpp
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> q;
        for(auto num:stones){
            q.push(num);
        }
        int x=-1,y=-1;
        while(q.size()>1){
            y=q.top();
            q.pop();
            x=q.top();
            q.pop();
            if(x!=y){
                q.push(y-x);
            }
        }
        if(q.empty()){
            return 0;
        }
        return q.top();
    }
};
```





